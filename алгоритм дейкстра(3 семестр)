class Node:

    def __init__(self, data, index_lc=None):
        self.data = data
        self.index = index_lc


class Graph:
    @classmethod
    def create_from_nodes(self, nodes):
        return Graph(len(nodes), len(nodes), nodes)

    def __init__(self, ryad, column, nodes=None):
        # установка матрицы смежности
        self.p_mat = [[0] * column for _ in range(ryad)]
        self.nodes = nodes
        for i in range(len(self.nodes)):
            self.nodes[i].index = i

    # Связываем node_1 с node_2
    def connect_dir(self, node_1, node_2, weight=1):
        node_1, node_2 = self.get_index_from_node(node_1), self.get_index_from_node(node_2)
        self.p_mat[node_1][node_2] = weight

    def connect(self, node_1, node_2, weight=1):
        self.connect_dir(node_1, node_2, weight)
        self.connect_dir(node_2, node_1, weight)

    def connection_from(self, node):
        node = self.get_index_from_node(node)
        return [(self.nodes[column_num], self.p_mat[node][column_num]) for column_num in range(len(self.p_mat[node])) if
                self.p_mat[node][column_num] != 0]

    def connection_to(self, node):
        node = self.get_index_from_node(node)
        column = [row[node] for row in self.p_mat]
        return [(self.nodes[row_num], column[row_num]) for row_num in range(len(column)) if column[row_num] != 0]

    def print_mat(self):
        for ryad in self.p_mat:
            print(ryad)

    def node(self, index):
        return self.nodes[index]

    def remove_conn(self, node_1, node_2):
        self.remove_conn_dir(node_1, node_2)
        self.remove_conn_dir(node_2, node_1)

    def remove_conn_dir(self, node_1, node_2):
        node_1, node_2 = self.get_index_from_node(node_1), self.get_index_from_node(node_2)
        self.p_mat[node_1][node_2] = 0

    def can_traverse_dir(self, node_1, node_2):
        node_1, node2 = self.get_index_from_node(node_1), self.get_index_from_node(node_2)
        return self.p_mat[node_1][node2] != 0

    def has_conn(self, node_1, node_2):
        return self.can_traverse_dir(node_1, node_2) or self.can_traverse_dir(node_2, node_1)

    def add_node(self, node):
        self.nodes.append(node)
        node.index = len(self.nodes) - 1
        for ryad in self.p_mat:
            ryad.append(0)
        self.p_mat.append([0] * (len(self.p_mat) + 1))

    def get_weight(self, n_1, n_2):
        node_1, node2 = self.get_index_from_node(n_1), self.get_index_from_node(n_2)
        return self.p_mat[node_1][node2]

    def get_index_from_node(self, node):
        if not isinstance(node, Node) and not isinstance(node, int):
            raise ValueError("node must be an integer or a Node object")
        if isinstance(node, int):
            return node
        else:
            return node.index


a = Node("A")
b = Node("B")
c = Node("C")
d = Node("D")
e = Node("E")
f = Node("F")

graph = Graph.create_from_nodes([a, b, c, d, e, f])

graph.connect(a, b)
graph.connect(a, c)
graph.connect(a, e)
graph.connect(b, c)
graph.connect(b, d)
graph.connect(c, d)
graph.connect(c, f)
graph.connect(d, e)

graph.print_mat()
